using System;
using System.Security.Cryptography;

namespace Bogosoft.Security.Passwords
{
    /// <summary>
    /// A password hashing implementation based on the PBKDF2 algorithm.
    /// </summary>
    public sealed class Pbkdf2PasswordHasher : IComparePasswords, IHashPasswords
    {
        int iterations;
        int size;

        /// <summary>
        /// Create a new instance of the <see cref="Pbkdf2PasswordHasher"/> class.
        /// </summary>
        /// <param name="size">
        /// A value corresponding to the desired size of any hash generated by an instance of this class
        /// </param>
        /// <param name="iterations">
        /// An optional value corresponding to the number of iterations the underlying key derivation function
        /// should use when generating a hash.
        /// </param>
        /// <exception cref="ArgumentException">
        /// Thrown in the event that either the given size or iterations parameters
        /// have a negative value.
        /// </exception>
        public Pbkdf2PasswordHasher(int size, int iterations = 65536)
        {
            if(size < 0)
            {
                throw new ArgumentException(Message.NegativeLength);
            }

            if(iterations < 0)
            {
                throw new ArgumentException(Message.NegativeIterations);
            }

            this.iterations = iterations;
            this.size = size;
        }

        /// <summary>
        /// Compare a given salt and password to a previously hashed password.
        /// </summary>
        /// <param name="salt">A sequence of bytes representing the salt.</param>
        /// <param name="password">A sequence of bytes representing the clear password.</param>
        /// <param name="hashed">
        /// A sequence of bytes representing a previous result of hashing a salt and password.
        /// </param>
        /// <returns>
        /// A value indicating whether or not the given salt and password equals the given hashed password.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown in the event that any given parameter is null.
        /// </exception>
        public bool Compare(byte[] salt, byte[] password, byte[] hashed)
        {
            if(salt == null)
            {
                throw new ArgumentNullException(nameof(salt));
            }

            if(password == null)
            {
                throw new ArgumentNullException(nameof(password));
            }

            if(hashed == null)
            {
                throw new ArgumentNullException(nameof(hashed));
            }

            return Hash(salt, password).ConstantTimeSequenceEquals(hashed);
        }

        /// <summary>
        /// Generate a password hash against a given salt and password.
        /// </summary>
        /// <param name="salt">A sequence of bytes representing a salt.</param>
        /// <param name="password">A sequence of bytes representing a clear password.</param>
        /// <returns>
        /// A sequence of bytes representing the result of hashing the given salt and password.
        /// </returns>
        public byte[] Hash(byte[] salt, byte[] password)
        {
            if (salt == null)
            {
                throw new ArgumentNullException(nameof(salt));
            }

            if (password == null)
            {
                throw new ArgumentNullException(nameof(password));
            }

            using (var hasher = new Rfc2898DeriveBytes(password, salt, iterations))
            {
                return hasher.GetBytes(size);
            }
        }
    }
}